import os
import re
import shutil

# ========= CONFIG =========
SOURCE_TF_FILE = "./gcs_terraform_export.tf"
TARGET_ROOT = "./terraform-gcp-infra"

GCS_MODULE_DIR = f"{TARGET_ROOT}/modules/gcs"
ENVS = ["dev", "qa", "prod"]

# ========= CREATE FOLDER STRUCTURE =========
os.makedirs(GCS_MODULE_DIR, exist_ok=True)

for env in ENVS:
    os.makedirs(f"{TARGET_ROOT}/envs/{env}", exist_ok=True)

os.makedirs(f"{TARGET_ROOT}/tfvars", exist_ok=True)

# ========= READ SOURCE FILE =========
with open(SOURCE_TF_FILE, "r") as f:
    content = f.read()

# ========= EXTRACT BUCKET RESOURCES =========
bucket_resources = re.findall(
    r'resource\s+"google_storage_bucket"\s+"[^"]+"\s+{[\s\S]*?^}',
    content,
    re.MULTILINE
)

# ========= SPLIT LIFECYCLE RULES =========
bucket_main_blocks = []
lifecycle_blocks = []

for block in bucket_resources:
    lifecycle = re.search(
        r'lifecycle_rule\s+{[\s\S]*?}',
        block,
        re.MULTILINE
    )

    if lifecycle:
        lifecycle_blocks.append(lifecycle.group())
        block = block.replace(lifecycle.group(), "")

    bucket_main_blocks.append(block)

# ========= WRITE module/gcs/main.tf =========
with open(f"{GCS_MODULE_DIR}/main.tf", "w") as f:
    f.write("\n\n".join(bucket_main_blocks))

# ========= WRITE module/gcs/lifecycle.tf =========
with open(f"{GCS_MODULE_DIR}/lifecycle.tf", "w") as f:
    for lc in lifecycle_blocks:
        f.write(
            f"""
resource "google_storage_bucket" "lifecycle_placeholder" {{
{lc}
}}
"""
        )

# ========= WRITE PLACEHOLDERS =========
files_with_placeholders = {
    "iam.tf": "# Bucket IAM bindings will be added after review\n",
    "variables.tf": "# GCS module variables\n",
    "outputs.tf": "# GCS module outputs\n",
}

for file, content in files_with_placeholders.items():
    with open(f"{GCS_MODULE_DIR}/{file}", "w") as f:
        f.write(content)

# ========= ROOT FILES =========
root_files = {
    "providers.tf": """provider "google" {}""",
    "backend.tf": "# Backend config will be enabled after approval\n",
    "main.tf": """module "gcs" {
  source = "./modules/gcs"
}""",
    "variables.tf": "# Root variables\n",
    "outputs.tf": "# Root outputs\n",
    "README.md": "# Terraform GCP Infra\n",
}

for file, content in root_files.items():
    with open(f"{TARGET_ROOT}/{file}", "w") as f:
        f.write(content)

# ========= ENV FILES =========
for env in ENVS:
    with open(f"{TARGET_ROOT}/envs/{env}/main.tf", "w") as f:
        f.write(
            f"""module "gcs" {{
  source = "../../modules/gcs"
}}"""
        )

# ========= TFVARS =========
for env in ENVS:
    with open(f"{TARGET_ROOT}/tfvars/hcb-{env}.tfvars", "w") as f:
        f.write("# Environment specific values\n")

print("âœ… GCS Terraform export reorganized into GitHub repo structure successfully")




























































-============================================================================================================


Perfect ğŸ‘ â€” thatâ€™s a **very common and very correct ask from leads**, especially in enterprise setups.

Let me break this down **clearly**, and then Iâ€™ll give you **exactly what to do**, **what to commit**, and **what status to report**.

---

# âœ… What your lead means by

> â€œSeparate Terraform **plan** and **apply**â€

### In simple terms:

* **Plan** = Safe, non-destructive, reviewable
* **Apply** = Risky, controlled, usually gated

Your responsibility **right now** is **ONLY up to `terraform plan`**.

---

# ğŸ¯ Your scope (very important)

You need to deliver:

âœ” Terraform code
âœ” Terraform backend (state config)
âœ” CI pipeline that runs **terraform init + terraform plan**
âŒ **NO terraform apply**
âŒ **NO infra creation**

This is **100% acceptable** and often mandatory.

---

# ğŸ§± Expected Architecture (What your lead wants)

```text
PR / Feature Branch
    â†“
GitHub Actions
    â†“
terraform init
terraform validate
terraform plan
    â†“
Plan output stored / uploaded
```

Then later:

```text
Main branch / Manual approval
    â†“
terraform apply   (separate pipeline)
```

---

# ğŸ›  What you need to implement (Step-by-step)

## 1ï¸âƒ£ Terraform repo structure (minimum)

```text
terraform/
â”œâ”€â”€ modules/
â”‚   â””â”€â”€ gcs-bucket/
â”‚       â”œâ”€â”€ main.tf
â”‚       â”œâ”€â”€ variables.tf
â”‚       â””â”€â”€ outputs.tf
â”œâ”€â”€ envs/
â”‚   â”œâ”€â”€ dev/
â”‚   â”‚   â”œâ”€â”€ main.tf
â”‚   â”‚   â”œâ”€â”€ backend.tf
â”‚   â”‚   â””â”€â”€ terraform.tfvars
â”‚   â””â”€â”€ qa/
â”‚       â”œâ”€â”€ main.tf
â”‚       â”œâ”€â”€ backend.tf
â”‚       â””â”€â”€ terraform.tfvars
â””â”€â”€ versions.tf
```

---

## 2ï¸âƒ£ Backend config (important even for plan)

Example `backend.tf`:

```hcl
terraform {
  backend "gcs" {
    bucket  = "tf-state-dev"
    prefix  = "gcs-buckets"
  }
}
```

Even if apply is not run, **backend must be configured**.

---

## 3ï¸âƒ£ GitHub Actions â€“ PLAN ONLY pipeline

### `.github/workflows/terraform-plan.yml`

```yaml
name: Terraform Plan

on:
  pull_request:
    branches:
      - main
  workflow_dispatch:

jobs:
  terraform-plan:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Terraform Init
        run: terraform init
        working-directory: terraform/envs/dev

      - name: Terraform Validate
        run: terraform validate
        working-directory: terraform/envs/dev

      - name: Terraform Plan
        run: terraform plan -out=tfplan
        working-directory: terraform/envs/dev
```

âœ” No apply
âœ” No approvals
âœ” Safe
âœ” Reviewable

---

## 4ï¸âƒ£ (Optional but good) Upload plan output

```yaml
      - name: Upload plan
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/envs/dev/tfplan
```

This makes your work **enterprise-grade**.

---

# âŒ What you should NOT do

ğŸš« Do not add:

```bash
terraform apply
```

ğŸš« Do not require approvals
ğŸš« Do not touch prod

---

# ğŸ§ª How to validate your work

Run locally:

```bash
terraform init
terraform validate
terraform plan
```

CI should show:

* âœ… Init success
* âœ… Plan generated
* âŒ No resources created

---

# ğŸ“Œ What to say in JIRA (very important)

### ğŸ”¹ Status Update (20â€“30% complete)

You can **safely post this** ğŸ‘‡

> **Status Update:**
> Terraform module structure and backend configuration are in progress.
> CI pipeline has been set up to run `terraform init`, `validate`, and `plan` (plan-only, no apply).
> Plan execution is being validated for DEV environment.
> Apply phase will be implemented as a separate workflow once approved.

This sounds **honest, professional, and aligned**.

---

# ğŸ—£ What to say in Scrum (1â€“2 lines)

> â€œIâ€™ve started with Terraform structure and CI setup.
> Terraform plan pipeline is in progress â€” apply will be a separate gated workflow.â€

This is **exactly what leads expect to hear**.

---

# ğŸ“ˆ How much is this complete?

| Task                    | %        |
| ----------------------- | -------- |
| Terraform code scaffold | 10%      |
| Backend config          | 5%       |
| Plan pipeline           | 15%      |
| Validation              | 5%       |
| **Total**               | **~35%** |

So **20â€“30% claim is very safe**.

---

# âœ… Final reassurance

You are:

* Following best practices
* Doing exactly what enterprise leads want
* Not overstepping scope
* Building future-ready pipelines

If you want next, I can:

* Draft the **separate apply pipeline**
* Add **manual approval gates**
* Review your Terraform module
* Help you reply back to your lead confidently

Just tell me ğŸ‘



---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------

















