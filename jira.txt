While developing Terraform modules for multiple GCP services (e.g., Pub/Sub, Artifact Registry, Dataplex, Secret Manager, etc.), some service-level IAM permissions are still pending for the Infra Service Account.

This story focuses on:

Testing Terraform plan/apply behavior

Capturing permission errors

Identifying exact IAM roles required

Documenting least-privilege access needs

üî∑ Scope
1Ô∏è‚É£ Terraform Plan Validation

Run terraform plan for each service module

Capture permission-related errors

Identify missing API enablement issues

2Ô∏è‚É£ Terraform Apply (Where Possible)

Attempt controlled apply in lower environment

Validate resource creation behavior

Rollback test resources if created

3Ô∏è‚É£ IAM Gap Analysis

Extract exact permission denied errors

Map required roles (e.g., roles/pubsub.admin, roles/artifactregistry.admin)

Avoid assigning overly broad roles (e.g., Owner/Editor)

4Ô∏è‚É£ API Enablement Verification

Confirm required GCP APIs are enabled

Identify missing service usage roles

üî∑ Services Under Testing (Example ‚Äì Modify Based on Your Context)

Pub/Sub

Artifact Registry

Secret Manager

Dataplex

Dataform

Vertex AI

Cloud Run

Monitoring / Alerting











Excellent üëå ‚Äî this is exactly how a spike should be documented:
Clear research ‚Üí validated steps ‚Üí recommended approach ‚Üí ready for implementation.

Below is a **Confluence-ready document** you can copy and paste.

---

# üõ° Enabler Spike ‚Äì HashiCorp Vault Integration

**Story:** TLIDCE-81
**Owner:** <Your Name>
**Type:** Spike (Feasibility & Integration Validation)

---

# 1. Objective

Evaluate and validate the integration of **HashiCorp Vault** for secure credential management in our application, replacing hardcoded sensitive credentials such as:

* Apigee X API Keys
* Ping Identity Client ID
* Ping Identity Client Secret

The goal is to ensure credentials are securely stored, centrally managed, and retrieved dynamically by the application.

---

# 2. Background

Currently, sensitive credentials are at risk of being hardcoded or stored in environment configurations. This introduces:

* Security risk
* Secret exposure risk
* Lack of centralized governance
* Poor secret rotation capabilities

HashiCorp Vault provides:

* Secure secret storage
* Policy-based access control
* Audit logging
* Secret rotation capability

---

# 3. High-Level Architecture

```
Application (K8s Pod)
        ‚Üì
Kubernetes Auth / JWT
        ‚Üì
Vault Engine
        ‚Üì
Secret Path
        ‚Üì
Environment Variables Injected into Pod
```

The application retrieves secrets from Vault dynamically via Kubernetes authentication and consumes them as environment variables.

---

# 4. Implementation Steps (Validated via Existing Project)

Based on reference implementation shared by Ramesh:

---

## Step 1: Setup Vault Engine

Vault engine must be enabled for the namespace.

Reference workflow:
`vault-k8s-jwt-auth/actions/workflows/apply-namespace-secr...`

After setup, verification can be done via:

Vault UI:

```
https://vault-nonprod.cvshealth.com/ui/vault/dashboard
```

Validation:

* Confirm namespace engine exists
* Confirm Kubernetes auth is enabled

---

## Step 2: Create Secrets in Vault

Secrets must be created under appropriate Vault path.

Example:

```
secret/data/<namespace>/<application>
```

Secrets stored:

* apigee_api_key
* ping_client_id
* ping_client_secret

Best Practice:

* Use logical naming conventions
* Avoid storing unrelated secrets in same path
* Follow least privilege policy model

---

## Step 3: Update Manifest Repository (Kubernetes Integration)

Manifest repo must be updated to allow application to read from Vault.

Reference example:

```
dev_aempptl_gke-gke_manifests/access-hub-dev/namespace
```

Changes required:

* Add Vault annotations
* Configure service account mapping
* Define Vault role binding
* Enable secret injection

This ensures:
K8s ServiceAccount ‚Üí Authenticates to Vault ‚Üí Allowed to read secret path

---

## Step 4: Update Application Configuration (v1.yaml)

Application config must read secrets from environment variables instead of hardcoding.

Reference:

```
ah-access-hub-bff/deploy-configs/access-hub-bff
```

Changes required:

* Remove hardcoded credentials
* Map environment variables to application config
* Validate fallback behavior

Example:

```yaml
env:
  - name: APIGEE_API_KEY
    valueFrom:
      secretKeyRef:
        name: vault-secret
        key: apigee_api_key
```

---

# 5. Error Handling Strategy

Application must:

* Fail fast if critical secrets are missing
* Log Vault access errors
* Provide fallback only where safe (non-critical secrets)

Recommended:

* No silent fallback for authentication credentials
* Explicit logging for Vault access issues

---

# 6. Security Considerations

‚úî Secrets not stored in Git
‚úî No hardcoding in application
‚úî RBAC enforced via Vault policies
‚úî Namespace isolation
‚úî Audit logs available in Vault

Future Improvements:

* Secret rotation policy validation
* Dynamic secret usage (where applicable)
* Token TTL management review

---

# 7. Risks Identified

| Risk                                             | Mitigation                     |
| ------------------------------------------------ | ------------------------------ |
| Vault availability dependency                    | Ensure high availability setup |
| Incorrect policy mapping                         | Strict RBAC review             |
| Improper secret path usage                       | Standardized naming convention |
| Application startup failure if Vault unreachable | Implement retry strategy       |

---

# 8. Feasibility Conclusion

Vault integration is:

‚úî Technically feasible
‚úî Aligns with enterprise security standards
‚úî Already validated in other CVS projects
‚úî Scalable across namespaces

No major blockers identified.

---

# 9. Recommended Implementation Approach

1. Enable Vault engine for namespace
2. Define standard secret path structure
3. Configure K8s authentication
4. Remove all hardcoded credentials
5. Validate in lower environment
6. Roll out progressively

---

# 10. Deliverables of This Spike

‚úî Validated integration approach
‚úî Documented implementation steps
‚úî Reviewed reference implementation
‚úî Identified risks & mitigations
‚úî Defined production rollout strategy

---

# 11. Next Steps (Implementation Story)

* Create production implementation story
* Define standard secret naming template
* Add Vault access checklist to onboarding guide
* Update CI/CD validation for secret usage

---

# Professional Scrum Update (You Can Say This)

### Option 1 ‚Äì Clean & Confident

> The Vault integration spike is complete from a technical validation perspective. I‚Äôve reviewed the existing implementation, validated the required setup steps, and documented the integration approach along with risks and recommendations. We‚Äôre ready to move to implementation once the follow-up story is created.

---

### Option 2 ‚Äì Slightly More Detailed

> I‚Äôve completed the Vault integration spike. The feasibility has been validated using the existing project reference, and I‚Äôve documented the setup steps, authentication flow, secret management approach, and recommended rollout strategy. We can now proceed with implementation.

---

### Option 3 ‚Äì Short Version

> The Vault spike is complete. Documentation and recommended implementation approach are finalized. Ready to transition to execution phase.

---

If you'd like, I can now also provide:

* A production-ready implementation story template
* A Vault governance checklist
* A diagram image description for architecture slide
* A strong leadership summary for sprint review

Just tell me üöÄ
